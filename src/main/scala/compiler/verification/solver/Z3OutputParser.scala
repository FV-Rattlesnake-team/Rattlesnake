package compiler.verification.solver

import compiler.Errors.ErrorReporter
import compiler.SourceCodeProvider
import compiler.irs.Tokens.*
import compiler.lexer.Lexer
import compiler.parser.LL1Iterator
import compiler.parser.ParseTree.^:
import compiler.parser.TreeParsers.*
import lang.Operator.{ClosingParenthesis, Minus, OpeningParenthesis}
import smtlib.trees.CommandsResponses.Success

import scala.util.matching.Regex
import scala.util.{Failure, Try}

object Z3OutputParser {

  private implicit val errorReporter: ErrorReporter = new ErrorReporter(_ => ())

  private lazy val openParenth = treeParser("(") {
    case OperatorToken(OpeningParenthesis) => ()
  }.setName("openParenth").ignored

  private lazy val closeParenth = treeParser(")") {
    case OperatorToken(ClosingParenthesis) => ()
  }.setName("closeParenth").ignored

  private lazy val dash = treeParser("-") {
    case OperatorToken(Minus) => ()
  }.setName("dash").ignored

  private lazy val define = treeParser("define") {
    case FirstLowercaseIdentifierToken("define") => ()
  }.setName("define").ignored

  private lazy val fun = treeParser("fun") {
    case FirstLowercaseIdentifierToken("fun") => ()
  }.setName("fun").ignored

  private lazy val sort = treeParser("sort") {
    case FirstUppercaseIdentifierToken(_) => ()
  }.setName("sort").ignored

  private lazy val anyStr = treeParser("variable value") {
    case anyTok => anyTok.strValue
  }.setName("anyStr")

  private lazy val funDef = {
    openParenth ::: define ::: dash ::: fun ::: anyStr ::: openParenth ::: closeParenth ::: sort ::: anyStr ::: closeParenth map {
      case id ^: value => id -> value
    }
  }.setName("funDef")

  private val endOfFile = treeParser("end of file") {
    case EndOfFileToken => ()
  }.setName("end of file").ignored

  private lazy val z3Output = openParenth ::: repeat(funDef) ::: closeParenth ::: endOfFile

  def parse(str: String): Try[Map[String, String]] = {
    // regex and part of the code were generated by ChatGPT
    val regex = """\(define-fun\s+([^()\s]+)\s+\(\)\s+Int\s+([^()\s]+)\)""".r
    regex.findFirstMatchIn(str) match {
      case Some(matched) if matched.groupCount % 2 == 0 =>
        scala.util.Success(
          regex.findAllMatchIn(str).map { m =>
            val name = m.group(1)
            val value = m.group(2)
            name -> value
          }.toMap)
      case _ =>
        Failure(new Exception("failed to parse z3 response"))
    }

  }

}
