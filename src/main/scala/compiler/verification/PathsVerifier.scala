package compiler.verification

import compiler.CompilationStep.Verification
import compiler.{CompilerStep, Position}
import compiler.Errors.{Err, ErrorReporter, errorsExitCode}
import compiler.irs.Asts
import compiler.irs.Asts.*
import compiler.verification.PathsVerifier.Score
import compiler.verification.solver.Solver
import compiler.verification.solver.Solver.*
import lang.Operator.*
import lang.{Operator, Types}
import lang.Types.PrimitiveType.*
import lang.Types.{ArrayType, PrimitiveType, StructType, Type, UndefinedType}
import smtlib.theories.Core.{BoolSort, Equals, False, Implies, Not, True}
import smtlib.theories.{Core, Ints}
import smtlib.theories.Ints.IntSort
import smtlib.trees.Terms.*
import smtlib.trees.Commands.{CheckSatAssuming, Command, DeclareConst, PropLiteral, Script, Assert as AssertCmd}

import java.util.concurrent.atomic.AtomicInteger
import scala.annotation.tailrec
import scala.collection.mutable.ListBuffer
import scala.util.{Failure, Success}

/**
 * Verifier for the paths of a program
 * @param solver solver to be used to verify the paths
 * @param timeoutSec timeout to be given to the solver, in seconds
 * @param logger function that will be given the messages generated by the verifier (e.g. path x was successively verified)
 */
final class PathsVerifier(
                           solver: Solver,
                           timeoutSec: Int,
                           errorReporter: ErrorReporter,
                           logger: String => Unit
                         ) extends CompilerStep[List[Path], Score] {

  private val atomicIntUid = new AtomicInteger(0)

  private def nextNameForNewVar(): String = {
    "%" ++ atomicIntUid.incrementAndGet().toString
  }

  override def apply(paths: List[Path]): Score = {
    solver.initialize()
    var correctCnt = 0
    for ((path, idx) <- paths.zipWithIndex) do {
      val base1Idx = idx + 1

      def genPrintableReport(msg: String, assigStr: String = ""): String = {
        s"$base1Idx - $msg : ${path.descr} $assigStr"
      }

      logger(
        verify(path, base1Idx, errorReporter) match
          case Solver.Sat(varsAssigDescr) => {
            genPrintableReport("FAILURE", varsAssigDescr)
          }
          case Solver.Unsat =>
            correctCnt += 1
            genPrintableReport("success")
          case Solver.Timeout(timeoutSec) => {
            genPrintableReport(s"TIMEOUT ($timeoutSec s)")
          }
          case Error(msg) => {
            genPrintableReport("ERROR: " ++ msg)
          }
      )
    }
    errorReporter.displayAndTerminateIfErrors()
    Score(correctCnt, paths.size)
  }

  /**
   * Mutable container for an error flag
   */
  private final class ErrorFlag {
    private var flag: Boolean = false

    def set(): Unit = {
      flag = true
    }

    def isSet: Boolean = flag
  }

  /**
   * Performs the verification of `path`, using `idx` as its index for debug info
   */
  private def verify(path: Path, idx: Int, errorReporter: ErrorReporter): Solver.Result = {
    val Path(stats, formulaToProve, descr) = path
    val errorFlag = new ErrorFlag()
    val additionalVarsBuffer = ListBuffer.empty[(String, Type)]
    val additionalFormulasBuffer = ListBuffer.empty[Term]
    val assumedFormulas = stats.map(generateFormula(_)(errorReporter, errorFlag, additionalVarsBuffer, additionalFormulasBuffer))
    val convertedFormulaToProve = transformExpr(formulaToProve)(errorReporter, errorFlag, additionalVarsBuffer, additionalFormulasBuffer)
    if (errorFlag.isSet) {
      Solver.Error("solver error")
    } else {
      val vars = (formulaToProve :: stats).flatMap(allVariables).toMap.toList // eliminate duplicates
      val varsDecls = {
        (vars ++ additionalVarsBuffer)
          .map((name, tpe) => DeclareConst(SSymbol(name), convertType(tpe)(errorReporter, errorFlag)))
      }
      val allAssumpt = assumedFormulas ++ additionalFormulasBuffer
      val assumptFormula = {
        allAssumpt match
          case Nil => True()
          case single :: Nil => single
          case _ => Core.And(allAssumpt)
      }
      val implication = Implies(
        assumptFormula,
        convertedFormulaToProve
      )
      val script = Script(varsDecls :+ AssertCmd(Not(implication)))
      solver.check(script, timeoutSec, s"target: $descr\n\n$path", idx)
    }
  }

  /**
   * Collect all local names appearing in `ast`
   */
  private def allVariables(ast: Ast): List[(String, Type)] = {
    ast.collectLs {
      case varRef@VariableRef(name) => {
        List((name, varRef.getType))
      }
      case LocalDef(localName, optType, rhs, _) => {
        val tpe = optType.getOrElse(rhs.getType)
        List((localName, tpe))
      }
    }
  }

  /**
   * Generate formulas for `statement`
   * 
   * Propagates implicit arguments that are used by `transformExpr`, especially `additVarsBuffer` and `additFormulasBuffer`, 
   * 2 path-wide mutable lists in which `transformExpr` writes additional formulas and variables
   */
  private def generateFormula(pathElement: Path.PathElement)(
    implicit errorReporter: ErrorReporter,
    errorFlag: ErrorFlag,
    additVarsBuffer: ListBuffer[(String, Type)],
    additFormulasBuffer: ListBuffer[Term]
  ): Term = {
    pathElement match
      case LocalDef(localName, _, rhs, _) =>
        Equals(qid(localName), transformExpr(rhs))
      case Assertion(formulaExpr, _, _) => // assumed in this path since it appears in the path
        transformExpr(formulaExpr)
      case VarAssig(lhs, rhs) =>
        // may need to be handled more carefully when implementing arrays
        Equals(transformExpr(lhs), transformExpr(rhs))
  }

  /**
   * Transforms a Rattlesnake AST expression into an SMT-lib expression
   * 
   * In some cases (especially ternary operators), generates additional formulas and variables, which are added 
   * to the mutable lists `additVarsBuffer` and `additFormulasBuffer`
   * @param errorFlag to be set if an error happens that makes verification impossible (so that the program continues 
   *                  generating expressions and thus looking for other errors, but stops before actually trying to 
   *                  verify the formula
   * @param additVarsBuffer mutable list in which additional variables will be written
   * @param additFormulasBuffer mutable list in which additional formulas will be written
   * @return the SMT-lib expression, <b>MIGHT BE NULL IF `errorFlag` HAS BEEN SET</b>, in which case the program should 
   *         continue generating the (degenerate) formula because it has to report all errors, but then stop before 
   *         verification occurs
   */
  private def transformExpr(expr: Expr)(
    implicit er: ErrorReporter,
    errorFlag: ErrorFlag,
    additVarsBuffer: ListBuffer[(String, Type)],
    additFormulasBuffer: ListBuffer[Term]
  ): Term = {
    if (expr.getType.subtypeOf(NothingType)) {
      reportUnsupported(s"expression with return type $NothingType", expr.getPosition)
    } else {
      expr match
        case IntLit(value) =>
          Ints.NumeralLit(value)
        case dLit@DoubleLit(_) =>
          reportUnsupported(DoubleType.str, dLit.getPosition)
        case cLit@CharLit(_) =>
          reportUnsupported(CharType.str, cLit.getPosition)
        case BoolLit(true) =>
          True()
        case BoolLit(false) =>
          False()
        case sLit@StringLit(_) =>
          reportUnsupported(StringType.str, sLit.getPosition)
        case VariableRef(name) =>
          qid(name)
        case call: Call =>
          val newVarName = nextNameForNewVar()
          additVarsBuffer.addOne(newVarName -> call.getType)
          qid(newVarName)  // variable with no constraint, since there is no postcondition
        case indexing@Indexing(_, _) =>
          reportUnsupported("array indexing", indexing.getPosition)
        case arrInit@ArrayInit(_, _) =>
          reportUnsupported("array initialization", arrInit.getPosition)
        case arrInit@FilledArrayInit(_) =>
          reportUnsupported("array initialization", arrInit.getPosition)
        case structInit@StructInit(_, _) =>
          reportUnsupported("struct initialization", structInit.getPosition)
        case UnaryOp(ExclamationMark, operand) =>
          Not(transformExpr(operand))
        case UnaryOp(Minus, operand) if operand.getType.subtypeOf(IntType) =>
          Ints.Neg(transformExpr(operand))
        case unOp@UnaryOp(Minus, operand) if operand.getType.subtypeOf(DoubleType) =>
          reportUnsupported(DoubleType.str, unOp.getPosition)
        case unOp@UnaryOp(Sharp, _) =>
          reportUnsupported(s"${Sharp.str}", unOp.getPosition)
        case unaryOp: UnaryOp =>
          throw new AssertionError(s"unexpected: $unaryOp")
        case binOp@BinaryOp(lhs, operator, rhs) => {
          if (operator == Equality) {
            Equals(transformExpr(lhs), transformExpr(rhs))
          } else if (lhs.getType.subtypeOf(BoolType)) {
            val transformedLhs = transformExpr(lhs)
            val transformedRhs = transformExpr(rhs)
            operator match {
              case And =>
                Core.And(transformedLhs, transformedRhs)
              case Or =>
                Core.Or(transformedLhs, transformedRhs)
              case _ =>
                assert(false)
            }
          } else if (lhs.getType.subtypeOf(IntType)) {
            convertOperatorToIntsTheoryOps(operator, lhs, rhs)
          } else {
            reportUnsupported(lhs.getType.toString, binOp.getPosition)
          }
        }
        case sel@Select(_, _) =>
          reportUnsupported("select", sel.getPosition)
        case ternary@Ternary(cond, thenBr, elseBr) =>
          val newVarName = nextNameForNewVar()
          val resVar = qid(newVarName)
          val condTransformed = transformExpr(cond)
          val thenTerm = Core.And(condTransformed, Equals(resVar, transformExpr(thenBr)))
          val elseTerm = Core.And(Not(condTransformed), Equals(resVar, transformExpr(elseBr)))
          additFormulasBuffer.addOne(Core.Or(thenTerm, elseTerm))
          additVarsBuffer.addOne(newVarName -> ternary.getType)
          resVar
        case cast@Cast(_, _) =>
          reportUnsupported("cast", cast.getPosition)
        case Sequence(_, Some(expr)) =>
          transformExpr(expr)
        case sequence: Sequence =>
          reportUnsupported("no value returned", sequence.getPosition)
    }
  }

  private def convertType(tpe: Type)(implicit errorReporter: ErrorReporter, errorFlag: ErrorFlag): Sort = {
    tpe match
      case IntType =>
        IntSort()
      case DoubleType =>
        reportUnsupported(tpe.toString, None)
      case CharType =>
        reportUnsupported(tpe.toString, None)
      case BoolType =>
        BoolSort()
      case StringType =>
        reportUnsupported(tpe.toString, None)
      case StructType(_) =>
        reportUnsupported(tpe.toString, None)
      case ArrayType(_) =>
        reportUnsupported(tpe.toString, None)
      case VoidType =>
        assert(false)
      case NothingType =>
        assert(false)
      case UndefinedType =>
        assert(false)
  }

  private def convertOperatorToIntsTheoryOps(
                                              operator: Operator,
                                              lhs: Expr,
                                              rhs: Expr
                                            )(
                                              implicit errorReporter: ErrorReporter,
                                              errorFlag: ErrorFlag,
                                              additVarsBuffer: ListBuffer[(String, Type)],
                                              additFormulasBuffer: ListBuffer[Term]
                                            ): Term = {
    val transformedLhs = transformExpr(lhs)
    val transformedRhs = transformExpr(rhs)
    operator match {
      case Plus =>
        Ints.Add(transformedLhs, transformedRhs)
      case Minus =>
        Ints.Sub(transformedLhs, transformedRhs)
      case Times =>
        Ints.Mul(transformedLhs, transformedRhs)
      case Div =>
        Ints.Div(transformedLhs, transformedRhs)
      case Modulo =>
        Ints.Mod(transformedLhs, transformedRhs)
      case Equality =>
        Equals(transformedLhs, transformedRhs)
      case Inequality =>
        Not(Equals(transformedLhs, transformedRhs))
      case LessThan =>
        Ints.LessThan(transformedLhs, transformedRhs)
      case LessOrEq =>
        Ints.LessEquals(transformedLhs, transformedRhs)
      case GreaterThan =>
        Ints.GreaterThan(transformedLhs, transformedRhs)
      case GreaterOrEq =>
        Ints.GreaterEquals(transformedLhs, transformedRhs)
      case _ => throw new AssertionError(s"unexpected: $operator")
    }
  }

  private def qid(name: String): QualifiedIdentifier = {
    QualifiedIdentifier(SimpleIdentifier(SSymbol(name)))
  }

  private def reportUnsupported(
                                 msg: String, posOpt: Option[Position]
                               )(implicit errorReporter: ErrorReporter, errorFlag: ErrorFlag): Null = {
    errorReporter.push(Err(Verification, "Not supported: " ++ msg, posOpt))
    errorFlag.set()
    null
  }

}

object PathsVerifier {
  
  final case class Score(passed: Int, total: Int){
    require(passed <= total)
    
    def allPassed: Boolean = (passed == total)

    override def toString: String = s"$passed/$total"
  }
  
}
